BEGIN;

CREATE TABLE sessions (
	token VARCHAR PRIMARY KEY DEFAULT random_string(16),
	uid INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	ts TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	events TEXT[]
);

CREATE OR REPLACE FUNCTION any_change_trigger_uid() RETURNS TRIGGER AS $$
BEGIN
	IF TG_OP = 'DELETE' THEN
		PERFORM pg_notify(TG_TABLE_NAME::TEXT, OLD.uid::TEXT);
	ELSE
		PERFORM pg_notify(TG_TABLE_NAME::TEXT, NEW.uid::TEXT);
	END IF;
	RETURN NEW;
END $$ LANGUAGE PlPgSQL;

CREATE TRIGGER sessions_change_trigger AFTER INSERT OR UPDATE OR DELETE
	ON sessions FOR EACH ROW EXECUTE PROCEDURE any_change_trigger_uid();
CREATE TRIGGER linetracker_change_trigger AFTER INSERT OR UPDATE OR DELETE
	ON linetracker FOR EACH ROW EXECUTE PROCEDURE any_change_trigger_uid();
CREATE TRIGGER blfs_change_trigger AFTER INSERT OR UPDATE OR DELETE
	ON blfs FOR EACH ROW EXECUTE PROCEDURE any_change_trigger_uid();

CREATE OR REPLACE FUNCTION regs_change_trigger() RETURNS TRIGGER AS $$
BEGIN
	IF TG_OP = 'DELETE' THEN
		PERFORM pg_notify(TG_TABLE_NAME::TEXT, OLD.userid::TEXT);
	ELSE
		PERFORM pg_notify(TG_TABLE_NAME::TEXT, NEW.userid::TEXT);
	END IF;
	RETURN NEW;
END $$ LANGUAGE PlPgSQL;
CREATE TRIGGER regs_change_trigger AFTER INSERT OR UPDATE OR DELETE
	ON regs FOR EACH ROW EXECUTE PROCEDURE regs_change_trigger();

COMMIT;

-- vim: ft=sql
